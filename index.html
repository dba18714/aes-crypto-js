<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AESåŠ å¯†è§£å¯†å·¥å…·</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <style>
      * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
      }
      
      body {
          font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          min-height: 100vh;
          padding: 20px;
      }
      
      .container {
          max-width: 900px;
          margin: 0 auto;
          background: white;
          border-radius: 15px;
          box-shadow: 0 20px 40px rgba(0,0,0,0.1);
          overflow: hidden;
      }
      
      .header {
          background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
          color: white;
          padding: 30px;
          text-align: center;
      }
      
      .header h1 {
          font-size: 2.5em;
          margin-bottom: 10px;
      }
      
      .header p {
          opacity: 0.9;
          font-size: 1.1em;
      }
      
      .content {
          padding: 40px;
      }
      
      .form-group {
          margin-bottom: 25px;
      }
      
      label {
          display: block;
          margin-bottom: 8px;
          font-weight: 600;
          color: #333;
          font-size: 1.1em;
      }
      
      input, textarea, select {
          width: 100%;
          padding: 12px;
          border: 2px solid #e1e5e9;
          border-radius: 8px;
          font-size: 16px;
          transition: border-color 0.3s ease;
      }
      
      input:focus, textarea:focus, select:focus {
          outline: none;
          border-color: #4facfe;
          box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
      }
      
      textarea {
          resize: vertical;
          min-height: 120px;
          font-family: 'Courier New', monospace;
      }
      
      .input-with-format {
          position: relative;
      }
      
      .format-toggle {
          display: flex;
          gap: 5px;
          margin-top: 8px;
      }
      
      .format-btn {
          padding: 4px 12px;
          border: 1px solid #ddd;
          background: #f8f9fa;
          border-radius: 15px;
          cursor: pointer;
          font-size: 12px;
          transition: all 0.3s ease;
      }
      
      .format-btn.active {
          background: #4facfe;
          color: white;
          border-color: #4facfe;
      }
      
      .format-btn:hover {
          background: #e9ecef;
      }
      
      .format-btn.active:hover {
          background: #3a8bfd;
      }
      
      .button-group {
          display: flex;
          gap: 15px;
          margin: 30px 0;
      }
      
      button {
          flex: 1;
          padding: 15px 25px;
          border: none;
          border-radius: 8px;
          font-size: 16px;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.3s ease;
      }
      
      .encrypt-btn {
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          color: white;
      }
      
      .decrypt-btn {
          background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
          color: white;
      }
      
      .clear-btn {
          background: #6c757d;
          color: white;
      }
      
      button:hover {
          transform: translateY(-2px);
          box-shadow: 0 5px 15px rgba(0,0,0,0.2);
      }
      
      button:active {
          transform: translateY(0);
      }
      
      .result {
          margin-top: 25px;
          padding: 20px;
          background: #f8f9fa;
          border-radius: 8px;
          border-left: 4px solid #4facfe;
      }
      
      .result h3 {
          color: #333;
          margin-bottom: 10px;
      }
      
      .error {
          background: #f8d7da;
          border-left-color: #dc3545;
          color: #721c24;
      }
      
      .success {
          background: #d4edda;
          border-left-color: #28a745;
          color: #155724;
      }
      
      .info-box {
          background: #e3f2fd;
          border: 1px solid #bbdefb;
          border-radius: 8px;
          padding: 15px;
          margin-bottom: 20px;
      }
      
      .info-box h4 {
          color: #1976d2;
          margin-bottom: 8px;
      }
      
      .info-box ul {
          color: #1565c0;
          margin-left: 20px;
      }
      
      .key-info {
          font-size: 12px;
          color: #666;
          margin-top: 5px;
      }
      
      .hex-input {
          font-family: 'Courier New', monospace;
      }
      
      .generate-group {
          display: flex;
          gap: 10px;
          margin-top: 10px;
      }
      
      .generate-btn {
          padding: 8px 16px;
          background: #28a745;
          color: white;
          border: none;
          border-radius: 5px;
          cursor: pointer;
          font-size: 14px;
          transition: background 0.3s ease;
      }
      
      .generate-btn:hover {
          background: #218838;
      }
      
      .convert-btn {
          padding: 8px 16px;
          background: #17a2b8;
          color: white;
          border: none;
          border-radius: 5px;
          cursor: pointer;
          font-size: 14px;
          transition: background 0.3s ease;
      }
      
      .convert-btn:hover {
          background: #138496;
      }
  </style>
</head>
<body>
  <div class="container">
      <div class="header">
          <h1>ğŸ” AESåŠ å¯†è§£å¯†å·¥å…·</h1>
          <p>å®‰å…¨å¯é çš„AESåŠ å¯†è§£å¯†æœåŠ¡ - æ”¯æŒæ–‡æœ¬å’Œ16è¿›åˆ¶æ ¼å¼</p>
      </div>
      
      <div class="content">
          <div class="info-box">
              <h4>ä½¿ç”¨è¯´æ˜ï¼š</h4>
              <ul>
                  <li>æ”¯æŒAES-128/192/256ä½åŠ å¯†</li>
                  <li>æ”¯æŒå¤šç§åŠ å¯†æ¨¡å¼ï¼ˆCBCã€ECBã€CFBã€OFBã€CTRï¼‰</li>
                  <li>å¯†é’¥å’ŒIVæ”¯æŒæ–‡æœ¬å’Œ16è¿›åˆ¶ä¸¤ç§æ ¼å¼</li>
                  <li>æ–‡æœ¬æ ¼å¼ï¼š16/24/32å­—ç¬¦ï¼›16è¿›åˆ¶æ ¼å¼ï¼š32/48/64å­—ç¬¦</li>
                  <li>æ‰€æœ‰æ“ä½œå‡åœ¨æœ¬åœ°å®Œæˆï¼Œä¸ä¼šä¸Šä¼ åˆ°æœåŠ¡å™¨</li>
              </ul>
          </div>
          
          <div class="form-group">
              <label>åŠ å¯†æ¨¡å¼</label>
              <select id="mode">
                  <option value="CBC">CBC (æ¨è)</option>
                  <option value="ECB">ECB</option>
                  <option value="CFB">CFB</option>
                  <option value="OFB">OFB</option>
                  <option value="CTR">CTR</option>
              </select>
          </div>
          
          <div class="form-group">
              <label>å¯†é’¥ (Key)</label>
              <div class="input-with-format">
                  <input type="text" id="key" placeholder="è¯·è¾“å…¥å¯†é’¥">
                  <div class="format-toggle">
                      <span class="format-btn active" data-format="text" data-target="key">æ–‡æœ¬</span>
                      <span class="format-btn" data-format="hex" data-target="key">16è¿›åˆ¶</span>
                  </div>
                  <div class="key-info">
                      <span id="keyInfo">æ–‡æœ¬æ ¼å¼ - å½“å‰é•¿åº¦: 0 å­—ç¬¦ (éœ€è¦16/24/32å­—ç¬¦)</span>
                  </div>
                  <div class="generate-group">
                      <button type="button" class="generate-btn" onclick="generateRandomKey()">ğŸ² ç”Ÿæˆéšæœºå¯†é’¥</button>
                      <button type="button" class="convert-btn" onclick="convertKeyFormat()">ğŸ”„ æ ¼å¼è½¬æ¢</button>
                  </div>
              </div>
          </div>
          
          <div class="form-group" id="ivGroup">
              <label>åˆå§‹åŒ–å‘é‡ (IV) - CBC/CFB/OFB/CTRæ¨¡å¼éœ€è¦</label>
              <div class="input-with-format">
                  <input type="text" id="iv" placeholder="è¯·è¾“å…¥IV">
                  <div class="format-toggle">
                      <span class="format-btn active" data-format="text" data-target="iv">æ–‡æœ¬</span>
                      <span class="format-btn" data-format="hex" data-target="iv">16è¿›åˆ¶</span>
                  </div>
                  <div class="key-info">
                      <span id="ivInfo">æ–‡æœ¬æ ¼å¼ - å½“å‰é•¿åº¦: 0 å­—ç¬¦ (éœ€è¦16å­—ç¬¦)</span>
                  </div>
                  <div class="generate-group">
                      <button type="button" class="generate-btn" onclick="generateRandomIV()">ğŸ² ç”ŸæˆéšæœºIV</button>
                      <button type="button" class="convert-btn" onclick="convertIVFormat()">ğŸ”„ æ ¼å¼è½¬æ¢</button>
                  </div>
              </div>
          </div>
          
          <div class="form-group">
              <label>è¾“å…¥æ–‡æœ¬</label>
              <div style="margin-bottom: 8px; color: #888; font-size: 0.98em;">
                  æ”¯æŒ <b>Base64</b> æˆ– <b>16è¿›åˆ¶</b> å¯†æ–‡ï¼Œç³»ç»Ÿè‡ªåŠ¨è¯†åˆ«æ ¼å¼ã€‚<br>
                  åŠ å¯†æ—¶è¾“å…¥æ˜æ–‡ï¼Œè§£å¯†æ—¶è¾“å…¥å¯†æ–‡ã€‚
              </div>
              <div style="display: flex; gap: 8px; align-items: center;">
                  <textarea id="inputText" placeholder="è¯·è¾“å…¥è¦åŠ å¯†æˆ–è§£å¯†çš„æ–‡æœ¬" style="flex:1;"></textarea>
                  <div style="display: flex; flex-direction: column; gap: 6px;">
                      <button type="button" class="convert-btn" style="padding:6px 10px;" onclick="pasteFromClipboard()">ğŸ“‹ ç²˜è´´</button>
                      <button type="button" class="clear-btn" style="padding:6px 10px; background:#dc3545;" onclick="clearInputText()">æ¸…ç©º</button>
                  </div>
              </div>
          </div>
          
          <div class="button-group">
              <button class="encrypt-btn" onclick="encryptText()">ğŸ”’ åŠ å¯†</button>
              <button class="decrypt-btn" onclick="decryptText()">ğŸ”“ è§£å¯†</button>
              <button class="clear-btn" onclick="clearAll()">ğŸ—‘ï¸ æ¸…ç©º</button>
          </div>
          
          <div id="result"></div>
      </div>
  </div>

  <script>
      let keyFormat = 'text';
      let ivFormat = 'text';
      
      // æ ¼å¼åˆ‡æ¢åŠŸèƒ½
      document.querySelectorAll('.format-btn').forEach(btn => {
          btn.addEventListener('click', function() {
              const target = this.dataset.target;
              const format = this.dataset.format;
              const group = this.parentElement;
              
              // æ›´æ–°æŒ‰é’®çŠ¶æ€
              group.querySelectorAll('.format-btn').forEach(b => b.classList.remove('active'));
              this.classList.add('active');
              
              // æ›´æ–°æ ¼å¼å˜é‡
              if (target === 'key') {
                  keyFormat = format;
                  updateKeyInfo();
              } else if (target === 'iv') {
                  ivFormat = format;
                  updateIVInfo();
              }
              
              // æ›´æ–°è¾“å…¥æ¡†æ ·å¼
              const input = document.getElementById(target);
              if (format === 'hex') {
                  input.classList.add('hex-input');
                  input.placeholder = target === 'key' ? 'è¯·è¾“å…¥16è¿›åˆ¶å¯†é’¥' : 'è¯·è¾“å…¥16è¿›åˆ¶IV';
              } else {
                  input.classList.remove('hex-input');
                  input.placeholder = target === 'key' ? 'è¯·è¾“å…¥å¯†é’¥' : 'è¯·è¾“å…¥IV';
              }
          });
      });
      
      // æ›´æ–°å¯†é’¥ä¿¡æ¯
      function updateKeyInfo() {
          const key = document.getElementById('key').value;
          const info = document.getElementById('keyInfo');
          
          if (keyFormat === 'text') {
              info.textContent = `æ–‡æœ¬æ ¼å¼ - å½“å‰é•¿åº¦: ${key.length} å­—ç¬¦ (éœ€è¦16/24/32å­—ç¬¦)`;
          } else {
              const hexLength = key.replace(/[^0-9a-fA-F]/g, '').length;
              info.textContent = `16è¿›åˆ¶æ ¼å¼ - å½“å‰é•¿åº¦: ${hexLength} å­—ç¬¦ (éœ€è¦32/48/64å­—ç¬¦)`;
          }
      }
      
      // æ›´æ–°IVä¿¡æ¯
      function updateIVInfo() {
          const iv = document.getElementById('iv').value;
          const info = document.getElementById('ivInfo');
          
          if (ivFormat === 'text') {
              info.textContent = `æ–‡æœ¬æ ¼å¼ - å½“å‰é•¿åº¦: ${iv.length} å­—ç¬¦ (éœ€è¦16å­—ç¬¦)`;
          } else {
              const hexLength = iv.replace(/[^0-9a-fA-F]/g, '').length;
              info.textContent = `16è¿›åˆ¶æ ¼å¼ - å½“å‰é•¿åº¦: ${hexLength} å­—ç¬¦ (éœ€è¦32å­—ç¬¦)`;
          }
      }
      
      // ç›‘å¬è¾“å…¥å˜åŒ–
      document.getElementById('key').addEventListener('input', updateKeyInfo);
      document.getElementById('iv').addEventListener('input', updateIVInfo);
      
      // æ ¹æ®æ¨¡å¼æ˜¾ç¤º/éšè—IVè¾“å…¥æ¡†
      document.getElementById('mode').addEventListener('change', function() {
          const ivGroup = document.getElementById('ivGroup');
          if (this.value === 'ECB') {
              ivGroup.style.display = 'none';
          } else {
              ivGroup.style.display = 'block';
          }
      });
      
      // éªŒè¯16è¿›åˆ¶å­—ç¬¦ä¸²
      function isValidHex(str) {
          return /^[0-9a-fA-F]*$/.test(str);
      }
      
      // æ–‡æœ¬è½¬16è¿›åˆ¶
      function textToHex(text) {
          return Array.from(text)
              .map(c => c.charCodeAt(0).toString(16).padStart(2, '0'))
              .join('');
      }
      
      // 16è¿›åˆ¶è½¬æ–‡æœ¬
      function hexToText(hex) {
          const cleanHex = hex.replace(/[^0-9a-fA-F]/g, '');
          if (cleanHex.length % 2 !== 0) {
              throw new Error('16è¿›åˆ¶å­—ç¬¦ä¸²é•¿åº¦å¿…é¡»æ˜¯å¶æ•°');
          }
          
          let result = '';
          for (let i = 0; i < cleanHex.length; i += 2) {
              result += String.fromCharCode(parseInt(cleanHex.substr(i, 2), 16));
          }
          return result;
      }
      
      // è§£æå¯†é’¥
      function parseKey(key, format) {
          if (format === 'hex') {
              const cleanHex = key.replace(/[^0-9a-fA-F]/g, '');
              if (!isValidHex(cleanHex)) {
                  throw new Error('å¯†é’¥åŒ…å«æ— æ•ˆçš„16è¿›åˆ¶å­—ç¬¦');
              }
              if (![32, 48, 64].includes(cleanHex.length)) {
                  throw new Error(`16è¿›åˆ¶å¯†é’¥é•¿åº¦å¿…é¡»æ˜¯32ã€48æˆ–64å­—ç¬¦ï¼Œå½“å‰é•¿åº¦ï¼š${cleanHex.length}`);
              }
              return CryptoJS.enc.Hex.parse(cleanHex);
          } else {
              if (![16, 24, 32].includes(key.length)) {
                  throw new Error(`æ–‡æœ¬å¯†é’¥é•¿åº¦å¿…é¡»æ˜¯16ã€24æˆ–32å­—ç¬¦ï¼Œå½“å‰é•¿åº¦ï¼š${key.length}`);
              }
              return CryptoJS.enc.Utf8.parse(key);
          }
      }
      
      // è§£æIV
      function parseIV(iv, format) {
          if (!iv) return null;
          
          if (format === 'hex') {
              const cleanHex = iv.replace(/[^0-9a-fA-F]/g, '');
              if (!isValidHex(cleanHex)) {
                  throw new Error('IVåŒ…å«æ— æ•ˆçš„16è¿›åˆ¶å­—ç¬¦');
              }
              if (cleanHex.length !== 32) {
                  throw new Error(`16è¿›åˆ¶IVé•¿åº¦å¿…é¡»æ˜¯32å­—ç¬¦ï¼Œå½“å‰é•¿åº¦ï¼š${cleanHex.length}`);
              }
              return CryptoJS.enc.Hex.parse(cleanHex);
          } else {
              if (iv.length !== 16) {
                  throw new Error(`æ–‡æœ¬IVé•¿åº¦å¿…é¡»æ˜¯16å­—ç¬¦ï¼Œå½“å‰é•¿åº¦ï¼š${iv.length}`);
              }
              return CryptoJS.enc.Utf8.parse(iv);
          }
      }
      
      // ç”Ÿæˆéšæœºå¯†é’¥
      function generateRandomKey() {
          const length = prompt('è¯·é€‰æ‹©å¯†é’¥é•¿åº¦ï¼š\n16å­—èŠ‚ - AES-128\n24å­—èŠ‚ - AES-192\n32å­—èŠ‚ - AES-256', '32');
          if (length && ['16', '24', '32'].includes(length)) {
              const keyInput = document.getElementById('key');
              if (keyFormat === 'hex') {
                  const hexLength = parseInt(length) * 2;
                  const randomBytes = CryptoJS.lib.WordArray.random(parseInt(length));
                  keyInput.value = randomBytes.toString(CryptoJS.enc.Hex);
              } else {
                  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
                  let result = '';
                  for (let i = 0; i < parseInt(length); i++) {
                      result += chars.charAt(Math.floor(Math.random() * chars.length));
                  }
                  keyInput.value = result;
              }
              updateKeyInfo();
          }
      }
      
      // ç”ŸæˆéšæœºIV
      function generateRandomIV() {
          const ivInput = document.getElementById('iv');
          if (ivFormat === 'hex') {
              const randomBytes = CryptoJS.lib.WordArray.random(16);
              ivInput.value = randomBytes.toString(CryptoJS.enc.Hex);
          } else {
              const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
              let result = '';
              for (let i = 0; i < 16; i++) {
                  result += chars.charAt(Math.floor(Math.random() * chars.length));
              }
              ivInput.value = result;
          }
          updateIVInfo();
      }
      
      // å¯†é’¥æ ¼å¼è½¬æ¢
      function convertKeyFormat() {
          const keyInput = document.getElementById('key');
          const key = keyInput.value;
          if (!key) {
              alert('è¯·å…ˆè¾“å…¥å¯†é’¥');
              return;
          }
          
          try {
              if (keyFormat === 'text') {
                  // æ–‡æœ¬è½¬16è¿›åˆ¶
                  keyInput.value = textToHex(key);
              } else {
                  // 16è¿›åˆ¶è½¬æ–‡æœ¬
                  keyInput.value = hexToText(key);
              }
              
              // åˆ‡æ¢æ ¼å¼
              const formatBtns = document.querySelectorAll('[data-target="key"]');
              formatBtns.forEach(btn => {
                  if (btn.dataset.format === keyFormat) {
                      btn.classList.remove('active');
                  } else {
                      btn.classList.add('active');
                  }
              });
              
              keyFormat = keyFormat === 'text' ? 'hex' : 'text';
              updateKeyInfo();
              
              // æ›´æ–°è¾“å…¥æ¡†æ ·å¼
              if (keyFormat === 'hex') {
                  keyInput.classList.add('hex-input');
                  keyInput.placeholder = 'è¯·è¾“å…¥16è¿›åˆ¶å¯†é’¥';
              } else {
                  keyInput.classList.remove('hex-input');
                  keyInput.placeholder = 'è¯·è¾“å…¥å¯†é’¥';
              }
              
          } catch (error) {
              alert('æ ¼å¼è½¬æ¢å¤±è´¥: ' + error.message);
          }
      }
      
      // IVæ ¼å¼è½¬æ¢
      function convertIVFormat() {
          const ivInput = document.getElementById('iv');
          const iv = ivInput.value;
          if (!iv) {
              alert('è¯·å…ˆè¾“å…¥IV');
              return;
          }
          
          try {
              if (ivFormat === 'text') {
                  // æ–‡æœ¬è½¬16è¿›åˆ¶
                  ivInput.value = textToHex(iv);
              } else {
                  // 16è¿›åˆ¶è½¬æ–‡æœ¬
                  ivInput.value = hexToText(iv);
              }
              
              // åˆ‡æ¢æ ¼å¼
              const formatBtns = document.querySelectorAll('[data-target="iv"]');
              formatBtns.forEach(btn => {
                  if (btn.dataset.format === ivFormat) {
                      btn.classList.remove('active');
                  } else {
                      btn.classList.add('active');
                  }
              });
              
              ivFormat = ivFormat === 'text' ? 'hex' : 'text';
              updateIVInfo();
              
              // æ›´æ–°è¾“å…¥æ¡†æ ·å¼
              if (ivFormat === 'hex') {
                  ivInput.classList.add('hex-input');
                  ivInput.placeholder = 'è¯·è¾“å…¥16è¿›åˆ¶IV';
              } else {
                  ivInput.classList.remove('hex-input');
                  ivInput.placeholder = 'è¯·è¾“å…¥IV';
              }
              
          } catch (error) {
              alert('æ ¼å¼è½¬æ¢å¤±è´¥: ' + error.message);
          }
      }
      
      function showResult(message, type = 'success') {
          const resultDiv = document.getElementById('result');
          resultDiv.innerHTML = `
              <div class="result ${type}">
                  <h3>${type === 'error' ? 'âŒ é”™è¯¯' : 'âœ… ç»“æœ'}</h3>
                  <div style="word-break: break-all; font-family: 'Courier New', monospace;">${message}</div>
              </div>
          `;
      }
      
      function getAESMode(mode) {
          switch(mode) {
              case 'CBC': return CryptoJS.mode.CBC;
              case 'ECB': return CryptoJS.mode.ECB;
              case 'CFB': return CryptoJS.mode.CFB;
              case 'OFB': return CryptoJS.mode.OFB;
              case 'CTR': return CryptoJS.mode.CTR;
              default: return CryptoJS.mode.CBC;
          }
      }
      
      function encryptText() {
          try {
              const key = document.getElementById('key').value;
              const iv = document.getElementById('iv').value;
              const inputText = document.getElementById('inputText').value;
              const mode = document.getElementById('mode').value;
              
              if (!key) {
                  throw new Error('è¯·è¾“å…¥å¯†é’¥');
              }
              
              if (!inputText) {
                  throw new Error('è¯·è¾“å…¥è¦åŠ å¯†çš„æ–‡æœ¬');
              }
              
              const keyWords = parseKey(key, keyFormat);
              let options = {
                  mode: getAESMode(mode),
                  padding: CryptoJS.pad.Pkcs7
              };
              
              let ivWords = null;
              let ivDisplay = 'æ— ï¼ˆECBæ¨¡å¼ï¼‰';
              let ivHex = '';
              let ivBase64 = '';
              if (mode !== 'ECB') {
                  if (!iv) {
                      throw new Error('å½“å‰æ¨¡å¼éœ€è¦IVï¼Œè¯·è¾“å…¥åˆå§‹åŒ–å‘é‡');
                  }
                  ivWords = parseIV(iv, ivFormat);
                  ivDisplay = iv;
                  options.iv = ivWords;
                  // è®¡ç®—IVçš„16è¿›åˆ¶å’Œbase64
                  ivHex = ivWords.toString(CryptoJS.enc.Hex);
                  ivBase64 = ivWords.toString(CryptoJS.enc.Base64);
              }
              
              const encrypted = CryptoJS.AES.encrypt(inputText, keyWords, options);
              const result = encrypted.toString();
              // è·å–16è¿›åˆ¶å¯†æ–‡
              const hexCipher = encrypted.ciphertext.toString(CryptoJS.enc.Hex);
              
              showResult(`<b>Base64å¯†æ–‡ï¼š</b><br>${result}<br><br><b>16è¿›åˆ¶å¯†æ–‡ï¼š</b><br>${hexCipher}<br><br><b>IVï¼ˆ16è¿›åˆ¶ï¼‰ï¼š</b><br>${ivHex || 'æ— '}<br><b>IVï¼ˆBase64ï¼‰ï¼š</b><br>${ivBase64 || 'æ— '}<br><br>ä½¿ç”¨çš„å¯†é’¥æ ¼å¼ï¼š${keyFormat === 'hex' ? '16è¿›åˆ¶' : 'æ–‡æœ¬'}<br>ä½¿ç”¨çš„IVæ ¼å¼ï¼š${ivFormat === 'hex' ? '16è¿›åˆ¶' : 'æ–‡æœ¬'}<br>ä½¿ç”¨çš„IVï¼š${ivDisplay}`);
              
          } catch (error) {
              showResult(error.message, 'error');
          }
      }
      
      function decryptText() {
          try {
              const key = document.getElementById('key').value;
              const iv = document.getElementById('iv').value;
              const inputText = document.getElementById('inputText').value;
              const mode = document.getElementById('mode').value;
              
              if (!key) {
                  throw new Error('è¯·è¾“å…¥å¯†é’¥');
              }
              
              if (!inputText) {
                  throw new Error('è¯·è¾“å…¥è¦è§£å¯†çš„æ–‡æœ¬');
              }
              
              const keyWords = parseKey(key, keyFormat);
              let options = {
                  mode: getAESMode(mode),
                  padding: CryptoJS.pad.Pkcs7
              };
              
              if (mode !== 'ECB') {
                  if (!iv) {
                      throw new Error('å½“å‰æ¨¡å¼éœ€è¦IVï¼Œè¯·è¾“å…¥åˆå§‹åŒ–å‘é‡');
                  }
                  const ivWords = parseIV(iv, ivFormat);
                  options.iv = ivWords;
              }
              
              // åˆ¤æ–­è¾“å…¥æ˜¯base64è¿˜æ˜¯16è¿›åˆ¶
              let cipherParams;
              if (/^[0-9a-fA-F]+$/.test(inputText) && inputText.length % 2 === 0) {
                  // 16è¿›åˆ¶å¯†æ–‡
                  cipherParams = CryptoJS.lib.CipherParams.create({
                      ciphertext: CryptoJS.enc.Hex.parse(inputText)
                  });
              } else {
                  // é»˜è®¤base64
                  cipherParams = inputText;
              }
              
              const decrypted = CryptoJS.AES.decrypt(cipherParams, keyWords, options);
              const result = decrypted.toString(CryptoJS.enc.Utf8);
              
              if (!result) {
                  throw new Error('è§£å¯†å¤±è´¥ï¼Œè¯·æ£€æŸ¥å¯†é’¥ã€IVå’ŒåŠ å¯†æ–‡æœ¬æ˜¯å¦æ­£ç¡®');
              }
              
              showResult(`è§£å¯†ç»“æœï¼š<br><br>${result}`);
              
          } catch (error) {
              showResult(error.message, 'error');
          }
      }
      
      function clearAll() {
          document.getElementById('key').value = '';
          document.getElementById('iv').value = '';
          document.getElementById('inputText').value = '';
          document.getElementById('result').innerHTML = '';
          updateKeyInfo();
          updateIVInfo();
      }
      
      function pasteFromClipboard() {
          navigator.clipboard.readText().then(text => {
              document.getElementById('inputText').value = text;
          });
      }
      
      function clearInputText() {
          document.getElementById('inputText').value = '';
      }
      
      // åˆå§‹åŒ–
      document.addEventListener('DOMContentLoaded', function() {
          updateKeyInfo();
          updateIVInfo();
      });
  </script>
</body>
</html>